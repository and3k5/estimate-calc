"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});class c{constructor(t,o,e,r,s,a,f,l){this.notation=t,this.singleName=o,this.multiName=e,this.propertyName=r,this.order=s,this.ms=a,this.relativeAmount=f,this.visibleByDefault=l}}const p=[new c("s","second","seconds","seconds",3,1e3,1e3,!1),new c("m","minute","minutes","minutes",2,1e3*60,60,!0),new c("h","hour","hours","hours",1,1e3*60*60,60,!1),new c("d","day","days","days",0,1e3*60*60*24,24,!1)];p.forEach((n,t,o)=>n.prev=o[t-1]);p.forEach((n,t,o)=>n.next=o[t+1]);const S=p;function N(n,t){if(!Array.isArray(n))throw new Error("First argument must be an array");return n.filter(e=>e.notation==t)[0]}class w{constructor({defaultNotations:t=!0,notationsEditor:o=null}={defaultNotations:!0,notationsEditor:null}){if(this.notations=[],t===!0)for(const e of S)this.notations.push(Object.assign({},e));typeof o=="function"&&o(this.notations)}}function y(n,t){const o=t<0;o&&(t=t*-1);const e=n.notations.concat().sort((s,a)=>a.ms-s.ms),r={};for(const s of e){const a=Math.floor(t/s.ms);r[s.propertyName]=o?a*-1:a,a>0&&(t-=a*s.ms)}return r}function E(n,t){let o=0;for(const e of n.notations)e.propertyName in t&&(o+=t[e.propertyName]*e.ms);return o}const T=/(?<amount>-?[0-9]+)(?<notation>[a-z])/gi;class j{get notationName(){return this.notation.propertyName}get value(){return y(this.time.setup,this.time.totalMs)[this.notationName]}set value(t){const o=y(this.time.setup,this.time.totalMs)[this.notationName],e=t-o;e!==0&&(this.time.totalMs+=this.notation.ms*e)}constructor(t,o){this.notation=o,this.time=t}}class u{constructor(t,o){if(this.values=[],this.totalMs=0,!(t instanceof w))throw new Error("Setup parameter required");this.setup=t;for(const e of t.notations)this.values.push(new j(this,e));typeof o=="string"?this.totalMs=u.parseTotalMsFromString(t,o):typeof o=="number"?this.totalMs=o:typeof o=="object"&&o instanceof u?this.totalMs=o.totalMs:typeof o=="object"&&o!=null&&(this.totalMs=E(t,o))}static parseTotalMsFromString(t,o){let e=0;for(const r of o.matchAll(T)){if(r.groups==null)throw new Error("missing groups");const s=N(t.notations,r.groups.notation);if(s==null)throw new Error("Did not find a notation for: "+r.groups.notation);e+=s.ms*parseInt(r.groups.amount)}return e}getNotationValue(t){const o=this.values.find(e=>e.notationName==t);if(o!=null)return o.value}add(t){for(const o of t.values){const e=this.values.find(r=>r.notationName==o.notationName);if(e==null)throw new Error("Time has different notation setup");e.value+=o.value}return this}sub(t){for(const o of t.values){const e=this.values.find(r=>r.notationName==o.notationName);if(e==null)throw new Error("Time has different notation setup");e.value-=o.value}return this}clone(){return new u(this.setup,this)}format(){const t=this.values.sort((o,e)=>o.notation.order-e.notation.order);return t.find(o=>o.value)==null?this.formatNotationValue(t.find(o=>o.notation.visibleByDefault===!0)||t[0]):this.formatNotationValues(t.filter(o=>o.value!==0))}formatNotationValues(t){return t.map(o=>this.formatNotationValue(o)).join(" ")}formatNotationValue(t){return t.value+""+t.notation.notation}}u.prototype.toString=function(){return this.format()};const x={name:"add",exec:function(n,t){return n.clone().add(t)}},I={name:"sub",exec:function(n,t){return n.clone().sub(t)}};function v(n){const t=[],o=Array.from(n);let e=0;const r=t,s=function(){o.splice(0,1),e++},a=function(){return o[0]},f=function(i){r.push(i)},l=function(){return r.length!==0&&typeof r[r.length-1]=="string"},M=function(i){l()||r.push(""),r[r.length-1]+=i};for(;o.length>0;){let i=a();if(i=="+")e>0&&f(x);else if(i=="-")e===0&&f("0m"),f(I);else if(i=="("){let m=0,d="";do{if(i==="("&&m++,s(),i=a(),i===")"&&(m--,m===0))break;d+=i}while(i!==")");f(v(d))}else(i.trim()!==""||l())&&M(i);s()}return t}function b(n,t){const o=[];return t.reduce((e,r)=>(typeof r=="string"?e.push(new u(n,r)):Array.isArray(r)?e.push(b(n,r)):e.push(r),e),o)}function B(n,t){const o=Array.isArray(t)?t.map(r=>"("+r+")").join(" + "):t,e=v(o);return b(n,e)}function h(n){if(n===null)return"null";if(n===void 0)return"undefined";if(Array.isArray(n)){let o=`array with ${n.length} item${n.length!==1?"s":""}`;if(n.length>0){const e=n.map(r=>h(r)).join(",");o+=` of the type${e.length!==1?"s":""} [${e}]`}return o}const t=typeof n;switch(t){case"bigint":case"boolean":case"function":case"number":case"string":case"symbol":return t}return n.constructor.name}function g(n){if(n instanceof u)return n;if(Array.isArray(n))return A(n);throw new Error("Unsupported type: "+h(n))}function O(n){if(n instanceof u)throw new Error("Unsupported type: "+h(n));if(Array.isArray(n))throw new Error("Unsupported type: "+h(n));return n}function A(n){for(;n.length>1;){const[t,o,e]=n.splice(0,3),r=g(t),s=g(e),a=O(o);n.splice(0,0,a.exec(r,s))}return n[0]}function P(n,t){const o=B(n,t);return A(o)}exports.TimeSetup=w;exports.getNotationByName=N;exports.parseInput=P;
